"use strict"

// Questions that can be asked at random by XAI.
const XAIQuestions = [
    XAIMetaSelect,
]


const beliefs = {
    // Concrete beliefs (clusters)
    posSize: {
        data: [],  // Sets of quality data
        cluster: [], // Clusters generated by ML
        novelty: 0,  // How random should our data be?
        originality: 0,  // Should our data be based on blends or unique points? 1 for blends.
        concreteness: 1, // 1 for data points, 0 for clusters. Anything in between a hybrid.
        clutering: 0,  // Whether to use something in a cluster.
    },
    fill:  {
        data: [],  // Sets of quality data
        cluster: [], // Clusters generated by ML
        novelty: 0,  // How random should our data be?
        originality: 0,  // Should our data be based on blends or unique points? 1 for blends.
        concreteness: 1, // 1 for data points, 0 for clusters. Anything in between a hybrid.
        clutering: 0,  // Whether to use something in a cluster.
    },
    stroke:  {
        data: [],  // Sets of quality data
        cluster: [], // Clusters generated by ML
        novelty: 0,  // How random should our data be?
        originality: 0,  // Should our data be based on blends or unique points? 1 for blends.
        concreteness: 1, // 1 for data points, 0 for clusters. Anything in between a hybrid.
        clutering: 0,  // Whether to use something in a cluster.
    },
    strokeWidth:  {
        data: [],  // Sets of quality data
        cluster: [], // Clusters generated by ML
        novelty: 0,  // How random should our data be?
        originality: 0,  // Should our data be based on blends or unique points? 1 for blends.
        concreteness: 1, // 1 for data points, 0 for clusters. Anything in between a hybrid.
        clutering: 0,  // Whether to use something in a cluster. (Gen 2)
    },

    number: {
        data: [],
        cluster: []
    },

    type: {
        data: [],
    },

    basisBelief: [], // A bare list of models of which we can base our creative drawings from.
    clips: {
        hardXMin: 0,
        hardYMin: 0,
        hardXMax: 1000,
        hardYMax: 1000,
        
        hardSizeMin: 0,
        hardSizeMax: 500,
        
        // Stroke width
        hardStrWMin: 0,
        hardStrWMax: 100,
        
        hardColorRange: 256,
    },
    
    // Template: {"image", "data"}
    image: {
        ratings: [],
        emotions: [],
    },
};

function BDIBeliefs() {
    
}
Object.assign(BDIBeliefs.prototype, beliefs);

const desires = {
    // Desire to ask questions to the user as a probability
    questions: 0.25,

    // Desire to give the user feedback
    feedback: 0.25,

    // Desires for shape generation
    number: {
        min: 1,
        target: 8,
        max: 64,
        
        clusters: 2,
        clusterVariance: 2,
    },

    // Desires to create better images:
    creativity: {
        novelty: 0,  // Controls global variance
        originality: 0,  // Controls blending
        concreteness: 1,  // Controls precision
        
        clustering: 1,
    },
    
    // Color choice desires (to generate creative images with specific colors)
    constantDesires: {
        fill: {
            target: [0, 0, 0, 0],
            adherence: 0
        },
        stroke: {
            target: [0, 0, 0, 0],
            adherence: 0
        },
        strokeWidth: {
            target: 3,
            adherence: 0
        }
    },
    
    // Choice of model to use.
    model: 1
};

function BDIDesires() {}
Object.assign(BDIDesires.prototype, desires);

// We have concrete and abstract analysis of information for BDI.
const bdiEngine =  {
    // The beliefs:
    // Concrete k-means clustered data (for all categories)
    
    // Abstract metadata beliefs:
    // Creative variance (overall)
    // Soft or hard selection
    
    // The desires
    
    // System desires:
    // XAI questions asked. (random selection)
    
    // User desires:
    // Modelling of user response to questions, and application to beliefs thereof.
    
    // The intentions
    // This program and its choices.
    
    // BELIEFS
    // Clusters of data.
    beliefs: new BDIBeliefs(),
    
    // Desires for the system
    desires: new BDIDesires(),
    
    // Intentions are what the BDI engine will do.
    intentions: {
        whole: {
            generateSingle(bdim) {
                // Select a model at random
                var randomSel = Math.floor(EMath.random() * (bdim.beliefs.basisBelief.length));
                
                var selected = bdim.beliefs.basisBelief[randomSel];
                return selected;
            },
            generateMultiple(bdim, n) {
                // Select a model at random
                var multis = [];
                
                for(var i = 0; i < n; i++) {
                    var localModel = bdim.intentions.whole.generateSingle(bdim);
                    for(var j = 0; j < localModel.objects.length; j++) {
                        multis.push(localModel.objects[j]);
                    }
                }
                
                var nim = new NeuralImageModel();
                nim.objects = multis;
                
                return nim;
            },
        },
        shape: {
            generateFromDataBelief(bdim) {
                // From the data belief, we select a random shape to be sent.
                var posData = bdim.beliefs.posSize.data;
                var fillData = bdim.beliefs.fill.data;
                var strokeData = bdim.beliefs.stroke.data;
                var swData = bdim.beliefs.strokeWidth.data;
                var typeData = bdim.beliefs.type.data;
                
                // Random for each category.
                var rPS = EMath.rsample(posData);
                var rFill = EMath.rsample(fillData);
                var rStroke = EMath.rsample(strokeData);
                var rSWidth = EMath.rsample(swData);
                var rT = EMath.rsample(typeData);
                
                // Create position
                var shape = new NeuralObject();
                bdim.intentions.mods.fillNewPosSize(bdim, shape, rPS);
                
                // Color
                shape.fill = rFill;
                shape.stroke = rStroke;
                shape.strokeWidth = rSWidth;
                
                shape.type = rT;
                
                return shape;
            },
            
            generateFromClusterBelief(bdim) {
                // From the data belief, we select a random shape to be sent.
                var posData = bdim.beliefs.posSize.cluster;
                var fillData = bdim.beliefs.fill.cluster;
                var strokeData = bdim.beliefs.stroke.cluster;
                var swData = bdim.beliefs.strokeWidth.cluster;
                
                // Only type is generated from data.
                var typeData = bdim.beliefs.type.data;
                
                // Random for each category.
                var rPS = EMath.rsample(posData);
                var rFill = EMath.rsample(fillData);
                var rStroke = EMath.rsample(strokeData);
                var rSWidth = EMath.rsample(swData);
                var rT = EMath.rsample(typeData);
                
                // Create position
                var shape = new NeuralObject();
                bdim.intentions.mods.fillNewPosSize(bdim, shape, rPS);
                
                // Color
                shape.fill = rFill;
                shape.stroke = rStroke;
                shape.strokeWidth = rSWidth;
                
                shape.type = rT;
                
                return shape;
            },
            
            generateFromNovelBelief(bdim) {
                // Only type is generated from data here.
                var typeData = bdim.beliefs.type.data;
                
                // Position is generated from the cluster.
                var posData = bdim.beliefs.posSize.cluster;
                var rPS = EMath.rsample(posData);
                
                // Create new shape
                var shape = new NeuralObject();
                
                bdim.intentions.mods.fillNewPosSize(bdim, shape, rPS);
                
                var rT = EMath.rsample(typeData);
                
                // Color
                shape.fill = [
                    EMath.randRange(0, bdim.beliefs.clips.hardColorRange), 
                    EMath.randRange(0, bdim.beliefs.clips.hardColorRange), 
                    EMath.randRange(0, bdim.beliefs.clips.hardColorRange),
                    EMath.randRange(0, bdim.beliefs.clips.hardColorRange)
                ];
                shape.stroke = [
                    EMath.randRange(0, bdim.beliefs.clips.hardColorRange), 
                    EMath.randRange(0, bdim.beliefs.clips.hardColorRange), 
                    EMath.randRange(0, bdim.beliefs.clips.hardColorRange),
                    EMath.randRange(0, bdim.beliefs.clips.hardColorRange)
                ];
                shape.strokeWidth = EMath.randRange(bdim.beliefs.clips.hardStrWMin, bdim.beliefs.clips.hardStrWMax);
                
                shape.type = rT;
                
                return shape;
            },
            
            generateSetFromDataBelief(bdim, n) {
                var nim = new NeuralImageModel();
                
                for(var i = 0; i < n; i++) {
                    var shape = bdim.intentions.shape.generateFromDataBelief(bdim);
                    nim.objects.push(shape);
                }
                
                return nim;
            },
            generateSetFromClusterBelief(bdim, n) {
                var nim = new NeuralImageModel();
                
                for(var i = 0; i < n; i++) {
                    var shape = bdim.intentions.shape.generateFromClusterBelief(bdim);
                    nim.objects.push(shape);
                }
                
                return nim;
            },
            generateSetFromNovelBelief(bdim, n) {
                var nim = new NeuralImageModel();
                
                for(var i = 0; i < n; i++) {
                    var shape = bdim.intentions.shape.generateFromNovelBelief(bdim);
                    nim.objects.push(shape);
                }
                
                return nim;
            }
        },
        mods: {
            fillNewPosSize(bdim, shape, pos) {
                shape.x = pos[0];
                shape.y = pos[1];
                shape.width = pos[2];
                shape.height = pos[3];
                
                return shape;
            },
            clampValues(bdim, shape) {
                // Clamp those that need to be clamped.
                shape.fill = EMath.clamp(shape.fill, 0, bdim.beliefs.clips.hardColorRange);
                shape.stroke = EMath.clamp(shape.stroke, 0, bdim.beliefs.clips.hardColorRange);
                shape.strokeWidth = EMath.clamp(shape.strokeWidth, bdim.beliefs.clips.hardStrWMin, bdim.beliefs.clips.hardStrWMax);
                
                return shape;
            },
            clampAll(bdim, img) {
                for(var i = 0; i < img.objects.length; i++) {
                    img.objects[i] = bdim.intentions.mods.clampValues(img.objects[i])
                }
                
                return img;
            },
            
            modifyFill(bdim, shape, val) {
                shape.fill = val;
                return shape;
            },
            modifyStroke(bdim, shape, val) {
                shape.stroke = val;
                return shape;
            },
            modifyStrokeWidth(bdim, shape, val) {
                shape.strokeWidth = val;
                return shape;
            },
            
            newFillFromBelief(bdim, shape, param) {
                // Generate from parameter
                var r = EMath.rsample(param);
                shape.fill = r;
                
                return shape;
            },
            
            newStrokeFromBelief(bdim, shape, param) {
                // Generate from parameter
                var r = EMath.rsample(param);
                shape.stroke = r;
                
                return shape;
            },
            
            newStrokeWidthFromBelief(bdim, shape, param) {
                // Generate from parameter
                var r = EMath.rsample(param);
                shape.strokeWidth = r;
                
                return shape;
            },
            
            newPosSizeFromBelief(bdim, shape, param) {
                // Generate from parameter
                var r = EMath.rsample(param);
                shape.x = r[0];
                shape.y = r[1];
                shape.width = r[2];
                shape.height = r[3];
                
                return shape;
            },
            
            novelColor(range=255) {
                return [EMath.random() * range, EMath.random() * range, EMath.random() * range, EMath.random() * range];
            },
            
            newBeliefFill(bdim, img, param) {
                for(var i = 0; i < img.objects.length; i++) {
                    img.objects[i] = bdim.intentions.mods.newFillFromBelief(bdim, img.objects[i], param);
                }
            },
            newBeliefStroke(bdim, img, param) {
                for(var i = 0; i < img.objects.length; i++) {
                    img.objects[i] = bdim.intentions.mods.newStrokeFromBelief(bdim, img.objects[i], param);
                }
            },
            newBeliefStrokeWidth(bdim, img, param) {
                for(var i = 0; i < img.objects.length; i++) {
                    img.objects[i] = bdim.intentions.mods.newStrokeWidthFromBelief(bdim, img.objects[i], param);
                }
            },
            
            doRandomFillParamSelection(bdim, shape, paramChoice) {
                if(paramChoice < 0.25) {
                    return shape;  // Leave as is
                }
                else if(paramChoice < 0.5) {
                    return bdim.intentions.mods.newFillFromBelief(bdim, shape, bdim.beliefs.fill.data);
                }
                else if(paramChoice < 0.75) {
                    return bdim.intentions.mods.newFillFromBelief(bdim, shape, bdim.beliefs.fill.cluster);
                }
                else {
                    // Completely novel
                    return bdim.intentions.mods.modifyFill(bdim, shape, bdim.intentions.mods.novelColor());
                }
            },
            
            doRandomStrokeParamSelection(bdim, shape, paramChoice) {
                if(paramChoice < 0.25) {
                    return shape;  // Leave as is
                }
                else if(paramChoice < 0.5) {
                    return bdim.intentions.mods.newStrokeFromBelief(bdim, shape, bdim.beliefs.stroke.data);
                }
                else if(paramChoice < 0.75) {
                    return bdim.intentions.mods.newStrokeFromBelief(bdim, shape, bdim.beliefs.stroke.cluster);
                }
                else {
                    // Completely novel
                    return bdim.intentions.mods.modifyStroke(bdim, shape, bdim.intentions.mods.novelColor());
                }
            },
            
            doRandomSWParamSelection(bdim, shape, paramChoice) {
                if(paramChoice < 0.25) {
                    return shape;  // Leave as is
                }
                else if(paramChoice < 0.5) {
                    return bdim.intentions.mods.newStrokeWidthFromBelief(bdim, shape, bdim.beliefs.strokeWidth.data);
                }
                else if(paramChoice < 0.75) {
                    return bdim.intentions.mods.newStrokeWidthFromBelief(bdim, shape, bdim.beliefs.strokeWidth.cluster);
                }
                else {
                    // Completely novel
                    return bdim.intentions.mods.modifyStrokeWidth(bdim, shape, EMath.random() * bdim.beliefs.clips.hardStrWMax);
                }
            },
            
            doRandomMovement(bdim, shape, paramChoice, varv = 1000, varp = 250) {
                if(paramChoice < 0.25) {
                    return shape;  // Leave as is
                }
                else if(paramChoice < 0.5) {
                    return bdim.intentions.mods.newPosSizeFromBelief(bdim, shape, bdim.beliefs.posSize.data);
                }
                else if(paramChoice < 0.75) {
                    return bdim.intentions.mods.newPosSizeFromBelief(bdim, shape, bdim.beliefs.posSize.cluster);
                }
                else {
                    // Completely novel displacement
                    return bdim.intentions.mods.fillNewPosSize(bdim, shape, [varv * EMath.random(), varv * EMath.random(), varp * EMath.random(), varp * EMath.random()]);
                }
            },
            morph(shape1, shape2) {
                var ns = new NeuralObject();
                
                // 0 or 1, randomly and independently.
                ns.type = EMath.applyDiscreteVariance(2);
                
                ns.x = (shape1.x + shape2.x) / 2;
                ns.y = (shape1.y + shape2.y) / 2;
                ns.width = (shape1.width + shape2.width) / 2;
                ns.height = (shape1.height + shape2.height) / 2;
            },
        },
    },
    
    lastImage: null,
    
    // XAI framework
    xai: {
        // Records for user input data (4 elements)
        userRatings: {
            creativity: 0,
            novelty: 0,
            originality: 0,
            quality: 0,
        },
        
        // Feedback framework.
        
        // All questions
        questions: XAIQuestions,
        
        // Ask XAI question
        askXAIQuestion(bdim, qu) {
            // console.log(qu)
            
            var genHTML = "<div class='XAIdesc'>" + qu.description + "</div>"
            
            // Try to prevent ID clashing.
            var randomSetting = EMath.applyDiscreteVariance(10000000);
            
            var ulAnsHTML = "<div class='XAIansers'>";
            
            for(var i = 0; i < qu.answers.length; i++) {
                var ansHTML = "<button class='XAIans' id='XAIans"+randomSetting+""+i+"'>" + qu.answers[i].text + "</button>";
                // console.log(ansHTML);
                ulAnsHTML += ansHTML;
            }
            
            ulAnsHTML += "</div>";
            
            var banner = painter.showBannerBox(genHTML + ulAnsHTML, "XAI", true);
            
            var customResponse = function(localI) {
                return function(event){
                    // Initiate response
                    qu.response(bdim, qu.answers[localI].value);
                    
                    // Close the banner - after response.
                    painter.deleteBannerBox(banner);
                };
            }
            
            // Close this when any button is clicked.
            for(var i = 0; i < qu.answers.length; i++) {
                $("#XAIans"+randomSetting+""+i).click(customResponse(i));
            }
        },
        
        askRandomXAIQuestion(bdim) {
            var ranSel = Math.floor(EMath.randRange(0, this.questions.length));
            
            this.askXAIQuestion(bdim, this.questions[ranSel]);
        },
    },
    
    clearBeliefs: function() {
        // Reset all beliefs here
        this.beliefs = new BDIBeliefs();
    },
    
    // Generate data beliefs
    organizeParsedDataIntoBeliefs: function(parsedData) {
        var collections = {
            posSize: [],
            fill: [],
            stroke: [],
            strokeWidth: []
        }
        
        // Remeld the data
        for(var i = 0; i < parsedData.x.length; i++) {
            collections.posSize.push([parsedData.x[i], parsedData.y[i], parsedData.w[i], parsedData.h[i]]);
            collections.fill.push(parsedData.fill[i]);
            collections.stroke.push(parsedData.stroke[i]);
            collections.strokeWidth.push(parsedData.strokeWidth[i]);
        }
        
        return collections;
    },
    
    createClusterBeliefs: function(dataBeliefs) {
        var clusters = {
            posSize: generateClusters(dataBeliefs.posSize, 4, 20, 0.05, 60, 8, 32, 2, this.beliefs.posSize.clusterBelief),
            fill: generateClusters(dataBeliefs.fill, 4, 20, 0.05, 60, 8, 32, 2, this.beliefs.fill.clusterBelief),
            stroke: generateClusters(dataBeliefs.stroke, 4, 20, 0.05, 60, 8, 32, 2, this.beliefs.stroke.clusterBelief),
            strokeWidth: generateClusters(dataBeliefs.strokeWidth, 4, 20, 0.05, 60, 8, 32, 2, this.beliefs.strokeWidth.clusterBelief),
        }
        
        return clusters;
    },
    
    getNoveltyBeliefs: function() {
        return {
            posSize: this.beliefs.posSize.novelty,
            fill: this.beliefs.fill.novelty,
            stroke: this.beliefs.stroke.novelty,
            strokeWidth: this.beliefs.strokeWidth.novelty,
        }
    },
    
    getOriginalityBeliefs: function() {
        return {
            posSize: this.beliefs.posSize.originality,
            fill: this.beliefs.fill.originality,
            stroke: this.beliefs.stroke.originality,
            strokeWidth: this.beliefs.strokeWidth.originality,
        }
    },
    
    getConcretenessBeliefs: function() {
        return {
            posSize: this.beliefs.posSize.concreteness,
            fill: this.beliefs.fill.concreteness,
            stroke: this.beliefs.stroke.concreteness,
            strokeWidth: this.beliefs.strokeWidth.concreteness,
        }
    },
    
    uniteBeliefs: function(dataBeliefs, clusterBeliefs, noveltyBeliefs, originalityBeliefs, concretenessBeliefs) {
        return {
            // Concrete beliefs (clusters)
            posSize: {
                data: dataBeliefs.posSize,  // Sets of quality data
                cluster: clusterBeliefs.posSize, // Clusters generated by ML
                novelty: noveltyBeliefs.posSize,  // How random should our data be?
                originality: originalityBeliefs.posSize,  // Should our data be based on blends or unique data points?
                concreteness: concretenessBeliefs.posSize,
            },
            fill:  {
                data: dataBeliefs.fill,
                cluster: clusterBeliefs.fill,
                novelty: noveltyBeliefs.fill,
                originality: originalityBeliefs.fill,
                concreteness: concretenessBeliefs.fill,
            },
            stroke:  {
                data: dataBeliefs.stroke,
                cluster: clusterBeliefs.stroke,
                novelty: noveltyBeliefs.stroke,
                originality: originalityBeliefs.stroke,
                concreteness: concretenessBeliefs.stroke,
            },
            strokeWidth:  {
                data: dataBeliefs.strokeWidth,
                cluster: clusterBeliefs.strokeWidth,
                novelty: noveltyBeliefs.strokeWidth,
                originality: originalityBeliefs.strokeWidth,
                concreteness: concretenessBeliefs.strokeWidth,
            }
        };
    },
    
    refineConcreteBeliefs: function(hotspotModel) {
        this.beliefs.basisBelief = hotspotModel.modelMemory;
        
        // For the model, parse it, then run the ML algorithms.
        var parsed = hotspotModel.modelParam();
        
        var objParsed = hotspotModel.obspecModelParam();
        
        var numData = objParsed.map(a => a.x.length);
        
        this.beliefs.number.data = numData;
        this.beliefs.number.cluster = generateClusters(numData, 4, 0, 0.05, 60, 8, 0.5, 2, this.beliefs.number.cluster);
        
        var typeData = parsed.type;
        
        this.beliefs.type.data = typeData;
        
        console.log(numData);
        
        // Organize the parameters.
        var dataBeliefs = this.organizeParsedDataIntoBeliefs(parsed);
        
        // Create clusters.
        var clusterBeliefs = this.createClusterBeliefs(dataBeliefs);
        
        // Create novelty and originality beliefs
        var noveltyBeliefs = this.getNoveltyBeliefs();
        var originalityBeliefs = this.getOriginalityBeliefs();
        var concretenessBeliefs = this.getConcretenessBeliefs();
        
        // Apply the data beliefs.
        var totalBel = this.uniteBeliefs(dataBeliefs, clusterBeliefs, noveltyBeliefs, originalityBeliefs, concretenessBeliefs);
        
        this.beliefs.posSize = totalBel.posSize;
        this.beliefs.fill = totalBel.fill;
        this.beliefs.stroke = totalBel.stroke;
        this.beliefs.strokeWidth = totalBel.strokeWidth;
    },
    
    refineBeliefs: function(hotspotModel) {
        this.refineConcreteBeliefs(hotspotModel);
    },
    
    refreshBeliefs: function(hotspotModel) {
        this.clearBeliefs();
        this.refineBeliefs(hotspotModel);
    },
    
    modellers: {
        gen1: function(myself) {
            // Here's the big part!

            // Blending in between clusters and data controlled by concreteness belief.

            // Our generative model is quite complex, but here it goes.

            // First, we pick a model, or a cluster, or we generate entirely randomly.

            // Now our parameters control for this.
            var globalConcreteness = myself.desires.creativity.concreteness;
            var globalVariance = myself.desires.creativity.novelty;
            var globalBlending = myself.desires.creativity.originality;

            // Discrete int.
            var globalClusters = myself.desires.number.clusters;
            var globalClusterVar = myself.desires.number.clusterVariance;
            var calcClusters = globalClusters + EMath.applyDiscreteVariance(globalClusterVar);

            var globalShapesTarget = myself.desires.number.target;
            var globalShapesVar = EMath.applyDiscreteVariance(globalShapesTarget);

            var globalShapesChoice = myself.desires.number.min + globalShapesVar;

            // Model programming time. The basis is selected from concreteness and variance (novelty)
            var basisSelect = EMath.clamp((1 - globalConcreteness) + ((2*EMath.random() - 1) * globalVariance), 0, 1);

            // Advanced model step. Which one to select?
            var advancedModel = myself.intentions.whole.generateMultiple(myself, globalClusters + EMath.applyDiscreteVariance(globalClusterVar));

            var dataBeliefModel = myself.intentions.shape.generateSetFromDataBelief(myself, globalClusters + EMath.applyDiscreteVariance(globalClusterVar));

            // Toy with data.
            var model;


            // Switch based on the basis select what model we should have
            if(basisSelect < 0.2) {
                model = myself.intentions.whole.generateSingle(myself);
            }
            else if(basisSelect < 0.4) {
                model = myself.intentions.whole.generateMultiple(myself, calcClusters);
            }
            else if(basisSelect < 0.6) {
                model = myself.intentions.shape.generateSetFromDataBelief(myself, globalShapesChoice * calcClusters);
            }
            else if(basisSelect < 0.8) {
                model = myself.intentions.shape.generateSetFromClusterBelief(myself, globalShapesChoice * calcClusters);
            }
            else {
                model = myself.intentions.shape.generateSetFromNovelBelief(myself, globalShapesChoice * calcClusters);
            }

            console.log("Basis: "+ basisSelect + ", Model: " + model);

            // Then we toy with the model.
            var modProbability = function(c, v) {
                return EMath.clamp(c + ((2*EMath.random() - 1) * v), 0, 1);
            }

            // We have a chance of modifying each property, for each shape.
            // FILL
            model.objects.map(function(shape) {
                // Modifying fill chance.
                var mp = modProbability(
                    (1 - myself.beliefs.fill.concreteness) / 2, 
                    (myself.beliefs.fill.novelty) / 2
                );
                return myself.intentions.mods.doRandomFillParamSelection(myself, shape, mp);
            });

            // STROKE
            model.objects.map(function(shape) {
                // Modifying fill chance.
                var mp = modProbability(
                    (1 - myself.beliefs.stroke.concreteness) / 2, 
                    (myself.beliefs.stroke.novelty) / 2
                );
                return myself.intentions.mods.doRandomStrokeParamSelection(myself, shape, mp);
            });


            // STROKE WIDTH
            model.objects.map(function(shape) {
                // Modifying fill chance.
                var mp = modProbability(
                    (1 - myself.beliefs.strokeWidth.concreteness) / 2, 
                    (myself.beliefs.strokeWidth.novelty) / 2
                );
                return myself.intentions.mods.doRandomSWParamSelection(myself, shape, mp);
            });

            // Random positioning
            model.objects.map(function(shape) {
                // Modifying fill chance.
                var mp = modProbability(
                    (1 - myself.beliefs.strokeWidth.concreteness) / 2, 
                    (myself.beliefs.strokeWidth.novelty) / 2
                );
                return myself.intentions.mods.doRandomMovement(myself, shape, mp);
            });
            
            return model;
        },
        
        gen2: function(myself) {
            function startingShapeBelief(basis=null, context=null) {
                var newShape = new NeuralObject();
                
                if(basis === null) {
                    newShape.x = EMath.randRange(0, painter.getSize()[0]);
                    newShape.y = EMath.randRange(0, painter.getSize()[1]);
                    newShape.width = EMath.randRange(myself.beliefs.clips.hardSizeMin, myself.beliefs.clips.hardSizeMax);
                    newShape.height = EMath.randRange(myself.beliefs.clips.hardSizeMin, myself.beliefs.clips.hardSizeMax);

                    newShape.fill = EMath.generateRandomRGBA();
                    newShape.stroke = EMath.generateRandomRGBA();
                    
                    newShape.strokeWidth = EMath.randRange(myself.beliefs.clips.hardStrWMin, myself.beliefs.clips.hardStrWMax);

                    newShape.type = NeuralObjectTypes.RECTANGLE;
                }
                else {
                    console.log("Basis def: ",basis)
                    newShape.x = basis.x;
                    newShape.y = basis.y;
                    newShape.width = basis.width;
                    newShape.height = basis.height;
                    
                    newShape.fill = basis.fill;
                    newShape.stroke = basis.stroke;
                    
                    newShape.strokeWidth = basis.strokeWidth;
                    
                    newShape.type = basis.type;
                }
                
                newShape.meta = {context: context, basis: basis};
                
                return newShape;
            }
            
            function continuingShapeBelief(lastShape, concrete=1, original=0) {
                // Prefer bases over original shapes, given concreteness.
                // Choose based on concreteness
                // More true when concreteness is lower.
                var randomChoice = EMath.random() > concrete;
                
                var contextExists = lastShape.meta.context != null;
                
                // If randomChoice is true, we go with something abstract and new.
                // Or if no context exists.
                if(randomChoice || !contextExists) {
                    // More true when original is higher
                    var randomOriginality = EMath.random() < original;
                    
                    var basis = lastShape? lastShape.meta.basis : null;
                    
                    if(randomOriginality) basis = null;
                    
                    // Base ourselves off the original shape's basis if we have the
                    // originality metric to go for it!
                    return startingShapeBelief(basis);
                }
                
                else {
                    // Base our shape off the context given by the last shape, if it exists.
                    // In the context, select a random object to base off.
                    var ctx = lastShape.meta.context;
                    
                    var ranObj = EMath.rsample(ctx.objects);
                    
                    // Then, we use this as our basis.
                    var newObj = startingShapeBelief(ranObj, ctx);
                    
                    return newObj;
                }
            }
            
            function adjustmentColorMorph(col1, col2, mf) {
                var newCol = [
                    EMath.clamp(col1[0] * (1 - mf) + col2[0] * mf, 0, myself.beliefs.clips.hardColorRange), 
                    EMath.clamp(col1[1] * (1 - mf) + col2[1] * mf, 0, myself.beliefs.clips.hardColorRange), 
                    EMath.clamp(col1[2] * (1 - mf) + col2[2] * mf, 0, myself.beliefs.clips.hardColorRange), 
                    EMath.clamp(col1[3] * (1 - mf) + col2[3] * mf, 0, 1), 
                ];
                
                return newCol;
            }
            
            function adjustmentColorAdjust(col1, mf) {
                var newCol = [
                    EMath.clamp(col1[0] + myself.beliefs.clips.hardColorRange*(2*EMath.random() - 1)*mf, 0, myself.beliefs.clips.hardColorRange), 
                    EMath.clamp(col1[1] + myself.beliefs.clips.hardColorRange*(2*EMath.random() - 1)*mf, 0, myself.beliefs.clips.hardColorRange), 
                    EMath.clamp(col1[2] + myself.beliefs.clips.hardColorRange*(2*EMath.random() - 1)*mf, 0, myself.beliefs.clips.hardColorRange), 
                    EMath.clamp(col1[3] + (2*EMath.random() - 1)*mf, 0, 1), // Alpha
                ];
                
                return newCol;
            }
            
            function adjustmentPSMorph(col1, col2, mf) {
                var newCol = [
                    col1[0] * (1 - mf) + col2[0] * mf, 
                    col1[1] * (1 - mf) + col2[1] * mf, 
                    col1[2] * (1 - mf) + col2[2] * mf, 
                    col1[3] * (1 - mf) + col2[3] * mf, 
                ];
                
                return newCol;
            }
            
            function adjustmentPSAdjust(col1, mf) {
                var newCol = [
                    col1[0] + 500*(2*EMath.random() - 1)*mf, 
                    col1[1] + 500*(2*EMath.random() - 1)*mf, 
                    col1[2] + 500*(2*EMath.random() - 1)*mf, 
                    col1[3] + 500*(2*EMath.random() - 1)*mf, 
                ];
                
                return newCol;
            }
            
            function adjustmentBeliefColor(shape, param, novelty = 1, originality = 1, target = [0, 0, 0, 0], adherence = 0) {
                // Modify the shape according to another.
                var ctx = shape.meta.context;
                
                var ourColor = Reflect.get(shape, param);
                
                var selectedShape = null;
                if(ctx !== null) {
                    selectedShape = EMath.rsample(ctx.objects);
                }
                
                var beNovel = EMath.random() < novelty;
                
                // Then modified by a morphing factor.
                var morphPercent = EMath.random() * originality;
                
                var newColor = ourColor;
                
                if(beNovel) {
                    // True if novelty is higher
                    selectedShape = null;
                    
                    // Randomly adjust by a color.
                    newColor = adjustmentColorAdjust(ourColor, morphPercent);
                }
                
                if(selectedShape !== null) {
                    // Base of selected shape.
                    var theirColor = Reflect.get(selectedShape, param);
                    // Morph between the colors.
                    newColor = adjustmentColorMorph(ourColor, theirColor, morphPercent);
                }
                
                console.log("Tar: ",target);
                console.log("Adh: ",adherence);
                
                // Adjustment for color cluster morphing.
                // (Specific creativity)
                var colMorph = helperAdd(helperMul(target, adherence), helperMul(newColor, 1-adherence));
                
                console.log(colMorph);
                
                Reflect.set(shape, param, colMorph);
                return shape;
            }
            
            function adjustmentBeliefPosition(shape, novelty = 1, originality = 1) {
                // Modify the shape according to another.
                var ctx = shape.meta.context;
                
                var ourPosSize = [shape.x, shape.y, shape.width, shape.height];
                
                var selectedShape = null;
                if(ctx !== null && (ctx.objects.length > 0)) {
                    selectedShape = EMath.rsample(ctx.objects);
                }
                
                var beNovel = EMath.random() < novelty;
                
                // Then modified by a morphing factor.
                var morphPercent = EMath.random() * originality;
                
                var newPosSize = ourPosSize;
                
                if(beNovel) {
                    // True if novelty is higher
                    selectedShape = null;
                    
                    // Randomly adjust by a color.
                    newPosSize = adjustmentPSAdjust(ourPosSize, morphPercent);
                }
                
                if(selectedShape !== null) {
                    // Base of selected shape.
                    var theirPosSize = [selectedShape.x, selectedShape.y, selectedShape.width, selectedShape.height];
                    // Morph between the colors.
                    newPosSize = adjustmentPSMorph(ourPosSize, theirPosSize, morphPercent);
                }
                
                // Position...
                shape.x = newPosSize[0];
                shape.y = newPosSize[1];
                shape.width = newPosSize[2];
                shape.height = newPosSize[3];
                
                return shape;
            }
            
            function adjustmentBeliefSingle(shape, param, novelty = 1, originality = 1, target = 0, adherence = 0) {
                // Modify the shape according to another.
                var ctx = shape.meta.context;
                
                var ourColor = Reflect.get(shape, param);
                
                var selectedShape = null;
                if(ctx !== null) {
                    selectedShape = EMath.rsample(ctx.objects);
                }
                
                var beNovel = EMath.random() < novelty;
                
                // Then modified by a morphing factor.
                var morphPercent = EMath.random() * originality;
                
                var newColor = ourColor;
                
                if(beNovel) {
                    // True if novelty is higher
                    selectedShape = null;
                    
                    // Randomly adjust by a color.
                    newColor = ourColor + (2*EMath.random() - 1) * morphPercent;
                }
                
                if(selectedShape !== null) {
                    // Base of selected shape.
                    var theirColor = Reflect.get(selectedShape, param);
                    // Morph between the colors.
                    newColor = ourColor * (1 - morphPercent) + theirColor * (morphPercent);
                }
                
                console.log("SWTar: ", target)
                console.log("SWAdh: ", adherence)
                
                var colMorph = helperAdd(helperMul(target, adherence), helperMul(newColor, 1-adherence));
                
                Reflect.set(shape, param, colMorph);
                return shape;
            }
            
            // Shape-based generator.
            function shapeMeld(shape) {
                // Position & size
                var posOrig = myself.beliefs.posSize.originality;
                var posNov = myself.beliefs.posSize.novelty;
                var posConc = myself.beliefs.posSize.concreteness;
                
                // When concreteness is lower, higher chance of being true.
                if(EMath.random() > posConc)
                    shape = adjustmentBeliefPosition(shape, posNov, posOrig);
                
                // Fill color
                var fillOrig = myself.beliefs.fill.originality;
                var fillNov = myself.beliefs.fill.novelty;
                var fillConc = myself.beliefs.fill.concreteness;
                
                // When asked to be concrete.
                if(EMath.random() > fillConc) {
                    shape = adjustmentBeliefColor(shape, "fill", fillNov, fillOrig,
                                                  myself.desires.constantDesires.fill.target, myself.desires.constantDesires.fill.adherence);
                }
                
                // Stroke color
                var strokeOrig = myself.beliefs.stroke.originality;
                var strokeNov = myself.beliefs.stroke.novelty;
                var strokeConc = myself.beliefs.stroke.concreteness;
                
                if(EMath.random() > strokeConc) {
                    shape = adjustmentBeliefColor(shape, "stroke", strokeNov, strokeOrig,
                                                 myself.desires.constantDesires.stroke.target, myself.desires.constantDesires.stroke.adherence);
                }
                
                // Stroke width
                var strokeWidthOrig = myself.beliefs.strokeWidth.originality;
                var strokeWidthNov = myself.beliefs.strokeWidth.novelty;
                var strokeWidthConc = myself.beliefs.strokeWidth.concreteness;
                
                if(EMath.random() > strokeWidthConc) {
                    shape = adjustmentBeliefSingle(shape, "strokeWidth", strokeWidthNov, strokeWidthOrig,
                                                 myself.desires.constantDesires.strokeWidth.target, myself.desires.constantDesires.strokeWidth.adherence);
                }
                
                return shape;
            }
            
            // Base ourselves off a shape belief - then position according to data.
            var gConcrete = myself.desires.creativity.concreteness;
            var gNovel = myself.desires.creativity.novelty;
            var gOriginal = myself.desires.creativity.originality;
            
            // Number of shapes to generate, then generate the shapes
            var numShapes = EMath.randRange(myself.desires.number.min, myself.desires.number.max);
            
            // Shape only model
            function shapeOnlyModel() {
                var startCluster = EMath.rsample(myself.beliefs.basisBelief);
            
                var startShape;
                if(startCluster.objects.length === 0) {
                    // Then set our basis to be just a random shape
                    startShape = startingShapeBelief();
                }
                else {
                    startShape = EMath.rsample(startCluster.objects);
                }

                // Check ultimate novelty before creating (basis, context)
                var firstShape = startingShapeBelief(startShape, startCluster);

                // If we decide to be more novel with generation...
                if(EMath.random() < gNovel) {
                    // Start off with nothing if told to be more novel.
                    firstShape = startingShapeBelief();
                }

                var lastShape = firstShape;

                var model = new NeuralImageModel();

                if(EMath.random() < gConcrete) {
                    numShapes = myself.desires.number.target;
                }

                for(var i = 0; i < numShapes; i++) {
                    console.log("Iteration "+i);
                    // Modify the first shape, and then add to the shapes list
                    lastShape = shapeMeld(lastShape);
                    console.log("LSF:", lastShape.fill);

                    // Add
                    model.objects.push(lastShape);

                    // Continue with a new model.
                    lastShape = continuingShapeBelief(lastShape, gConcrete, gOriginal);
                }
                
                return model;
            }
            
            
            // Clustered model
            function clusteredModel() {
                var startCluster = EMath.rsample(myself.beliefs.basisBelief);
                
                var newModel = new NeuralImageModel();
                
                console.log("Cluster model");
                
                for(var i = 0; i < startCluster.objects.length; i++) {
                    var copyShape = startCluster.objects[i];
                    
                    var newShape = startingShapeBelief(copyShape, startCluster);
                    
                    console.log(newShape.x);
                    
                    newShape = shapeMeld(newShape);
                    
                    console.log(newShape.fill);
                    
                    newModel.objects.push(newShape);
                }
                
                console.log(newModel);
                
                return newModel;
            }
            
            // Less than means a yes
            var clusterDesire = Math.random() < myself.desires.creativity.clustering;
            
            var ultimateModel = (clusterDesire)? clusteredModel() : shapeOnlyModel();
            
            console.log("Ult: ", ultimateModel);
            
            return ultimateModel;
        },
    },
    
    getModellerList() {
        return [this.modellers.gen1, this.modellers.gen2];
    },
    
    // Generate from BDI model.
    generateFromBDI: function() {
        // Select a model from the desires
        var modelSelect = this.getModellerList()[this.desires.model];
        var model = modelSelect(this);
        this.lastImage = model;
        return model;
    },
    
    runDesiresStep() {
        var randomAsk = EMath.random() <= this.desires.questions;
        
        // Randomly ask a question if we want it.
        if(randomAsk) {
            this.xai.askRandomXAIQuestion(this);
        }
    },
    
    askQuestionIntention() {
        this.xai.askRandomXAIQuestion(this);
    },
}

// Constructor
function BDIEngine() {
    
}

Object.assign(BDIEngine.prototype, bdiEngine);
