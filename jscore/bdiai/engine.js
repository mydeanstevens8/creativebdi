"use strict"

function helperSampleUnif(varb) {
    return varb.target + varb.var * (EMath.random() * 2 - 1); 
}

function helperStartSamp(svarb) {
    return [
        svarb.x + svarb.varX * (EMath.random() * 2 - 1),
        svarb.y + svarb.varY * (EMath.random() * 2 - 1)
    ];
}

// We have concrete and abstract analysis of information for BDI.
const bdiEngine =  {
    // The beliefs:
    // Concrete k-means clustered data (for all categories)
    
    // Abstract metadata beliefs:
    // Creative variance (overall)
    // Soft or hard selection
    
    // The desires
    
    // System desires:
    // XAI questions asked. (random selection)
    
    // User desires:
    // Modelling of user response to questions, and application to beliefs thereof.
    
    // The intentions
    // This program and its choices.
    
    // BELIEFS
    // Clusters of data.
    beliefs: new BDIBeliefs(),
    
    // Desires for the system
    desires: new BDIDesires(),
    
    // Intentions are what the BDI engine will do.
    intentions: new BDIIntentions(),
    
    lastImage: null,
    
    // XAI questions framework
    xai: new XQuests(),
    
    clearBeliefs: function() {
        // Reset all beliefs here
        this.beliefs = new BDIBeliefs();
    },
    
    // Generate data beliefs
    organizeParsedDataIntoBeliefs: function(parsedData) {
        var collections = {
            posSize: [],
            fill: [],
            stroke: [],
            strokeWidth: []
        }
        
        // Remeld the data
        for(var i = 0; i < parsedData.x.length; i++) {
            collections.posSize.push([parsedData.x[i], parsedData.y[i], parsedData.w[i], parsedData.h[i]]);
            collections.fill.push(parsedData.fill[i]);
            collections.stroke.push(parsedData.stroke[i]);
            collections.strokeWidth.push(parsedData.strokeWidth[i]);
        }
        
        return collections;
    },
    
    createClusterBeliefs: function(dataBeliefs) {
        var clusters = {
            posSize: generateClusters(dataBeliefs.posSize, 4, 20, 0.05, 60, 8, 32, 2, this.beliefs.posSize.clusterBelief),
            fill: generateClusters(dataBeliefs.fill, 4, 20, 0.05, 60, 8, 32, 2, this.beliefs.fill.clusterBelief),
            stroke: generateClusters(dataBeliefs.stroke, 4, 20, 0.05, 60, 8, 32, 2, this.beliefs.stroke.clusterBelief),
            strokeWidth: generateClusters(dataBeliefs.strokeWidth, 4, 20, 0.05, 60, 8, 32, 2, this.beliefs.strokeWidth.clusterBelief),
        }
        
        return clusters;
    },
    
    getNoveltyBeliefs: function() {
        return {
            posSize: this.beliefs.posSize.novelty,
            fill: this.beliefs.fill.novelty,
            stroke: this.beliefs.stroke.novelty,
            strokeWidth: this.beliefs.strokeWidth.novelty,
        }
    },
    
    getOriginalityBeliefs: function() {
        return {
            posSize: this.beliefs.posSize.originality,
            fill: this.beliefs.fill.originality,
            stroke: this.beliefs.stroke.originality,
            strokeWidth: this.beliefs.strokeWidth.originality,
        }
    },
    
    getConcretenessBeliefs: function() {
        return {
            posSize: this.beliefs.posSize.concreteness,
            fill: this.beliefs.fill.concreteness,
            stroke: this.beliefs.stroke.concreteness,
            strokeWidth: this.beliefs.strokeWidth.concreteness,
        }
    },
    
    uniteBeliefs: function(dataBeliefs, clusterBeliefs, noveltyBeliefs, originalityBeliefs, concretenessBeliefs) {
        return {
            // Concrete beliefs (clusters)
            posSize: {
                data: dataBeliefs.posSize,  // Sets of quality data
                cluster: clusterBeliefs.posSize, // Clusters generated by ML
                novelty: noveltyBeliefs.posSize,  // How random should our data be?
                originality: originalityBeliefs.posSize,  // Should our data be based on blends or unique data points?
                concreteness: concretenessBeliefs.posSize,
            },
            fill:  {
                data: dataBeliefs.fill,
                cluster: clusterBeliefs.fill,
                novelty: noveltyBeliefs.fill,
                originality: originalityBeliefs.fill,
                concreteness: concretenessBeliefs.fill,
            },
            stroke:  {
                data: dataBeliefs.stroke,
                cluster: clusterBeliefs.stroke,
                novelty: noveltyBeliefs.stroke,
                originality: originalityBeliefs.stroke,
                concreteness: concretenessBeliefs.stroke,
            },
            strokeWidth:  {
                data: dataBeliefs.strokeWidth,
                cluster: clusterBeliefs.strokeWidth,
                novelty: noveltyBeliefs.strokeWidth,
                originality: originalityBeliefs.strokeWidth,
                concreteness: concretenessBeliefs.strokeWidth,
            }
        };
    },
    
    refineConcreteBeliefs: function(hotspotModel) {
        this.beliefs.basisBelief = hotspotModel.modelMemory;
        
        // For the model, parse it, then run the ML algorithms.
        var parsed = hotspotModel.modelParam();
        
        var objParsed = hotspotModel.obspecModelParam();
        
        var numData = objParsed.map(a => a.x.length);
        
        this.beliefs.number.data = numData;
        this.beliefs.number.cluster = generateClusters(numData, 4, 0, 0.05, 60, 8, 0.5, 2, this.beliefs.number.cluster);
        
        var typeData = parsed.type;
        
        this.beliefs.type.data = typeData;
        
        console.log(numData);
        
        // Organize the parameters.
        var dataBeliefs = this.organizeParsedDataIntoBeliefs(parsed);
        
        // Create clusters.
        var clusterBeliefs = this.createClusterBeliefs(dataBeliefs);
        
        // Create novelty and originality beliefs
        var noveltyBeliefs = this.getNoveltyBeliefs();
        var originalityBeliefs = this.getOriginalityBeliefs();
        var concretenessBeliefs = this.getConcretenessBeliefs();
        
        // Apply the data beliefs.
        var totalBel = this.uniteBeliefs(dataBeliefs, clusterBeliefs, noveltyBeliefs, originalityBeliefs, concretenessBeliefs);
        
        this.beliefs.posSize = totalBel.posSize;
        this.beliefs.fill = totalBel.fill;
        this.beliefs.stroke = totalBel.stroke;
        this.beliefs.strokeWidth = totalBel.strokeWidth;
    },
    
    refineBeliefs: function(hotspotModel) {
        this.refineConcreteBeliefs(hotspotModel);
    },
    
    refreshBeliefs: function(hotspotModel) {
        this.clearBeliefs();
        this.refineBeliefs(hotspotModel);
    },
    
    getModellerList() {
        return [IntentionClusterModel, IntentionShapeSynthesisModel, IntentionLineModel];
    },
    
    updateLastShape() {
        var mod = helperCreateNeuralImageModel();
        
        // Last shape is assumed to be the last element
        if(mod.objects.length > 0) {
            var lS = mod.objects[mod.objects.length - 1];
            
            console.log("Last shape:", lS)
            
            this.beliefs.lastShape = lS;
        }
        else{
            this.beliefs.lastShape = null;
        }
    },
    
    // Generate from BDI model.
    generateFromBDI: function() {
        // Update the last shape belief.
        this.updateLastShape();
        
        // Select a model from the desires
        var modelSelect = this.getModellerList()[this.desires.model];
        var model = modelSelect(this);
        this.lastImage = model;
        return model;
    },
    
    runDesiresStep() {
        var randomAsk = EMath.random() <= this.desires.questions;
        
        // Randomly ask a question if we want it.
        if(randomAsk) {
            this.xai.askRandomXAIQuestion(this);
        }
    },
    
    askQuestionIntention() {
        this.xai.askRandomXAIQuestion(this);
    },
}

// Constructor
function BDIEngine() {
    
}

Object.assign(BDIEngine.prototype, bdiEngine);
