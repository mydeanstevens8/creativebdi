"use strict"

const SAVE_PATH = "saveapi.php";
const BDI_SAVE_PATH = "bdisave.php";

// Here, we use an AI known to me as Hotspots, which models using a neural network some hotspots
// where creativity happens.
// To explain the AI, we test the AI on some general data, and then we interpret the results (and trends).

// To implement the AI, we need to understand its parameters.
// Using only JavaScript here...

// Hotspot BDI model
const hotspots = {
    // Memory. A list of neural image models
    modelMemory: [],
    
    // Hotspot BDI engine
    bdiEngine: new BDIEngine(),
    
    // Position network
    
    // The whole generative network generates one object
    // Generated by tensorflow.
    // Inputs: seed, count, pos, prev_encoded_data ... 
    // Outputs: type (square, circle), X pos, Y pos, X size, Y size, Fill color (R, G, B, A), Line color (R, G, B, A), 
    // Stroke width
    genNetwork: null,
    
    // The gen network can be broken down into an Expectation and Variance decomposition
    // in some layer, of which we can analyse.
    
    // Create the model content
    
    // ...
    
    // As for color and stroke width, we use a expectation and variance hotspot model for quick results.
    
    
    // For position and size, we use a neural model. This is slower, but works for large datasets.
    // For the model, we are inspired by our previous beliefs. If the user rates the creativity as low, we
    // have a lower chance of selecting such in the future.
    
    // Convert SVG to PNG to sample.
    convertPNG: async function(svgData) {
        // Run an external converter through the AJAX
        // Thanks to setup instructions from (https://github.com/ssssota/svg2png-wasm) (2022)
        await svg2pngWasm.initialize(fetch('https://unpkg.com/svg2png-wasm/svg2png_wasm_bg.wasm'));
        const font = await fetch('./Roboto.ttf').then((res) => res.arrayBuffer());
        
        /** @type {Uint8Array} */
        const png = await svg2pngWasm.svg2png(svgData);
        
//        document.getElementById('output').src = URL.createObjectURL(
//            new Blob([png], { type: 'image/png' }),
//        );
        return new Blob([png], { type: 'image/png' });
    },
    
    
    // Similarity score between PNG images...
    
    // Attempts to fit our SVG images to some PNG image.
    
    
    // SVG expectations model.
    
    
    
    // Provide images for training the model.
    provideTrainingImages: function(dataset) {
        // When we load the images, we train the model based off these images. In particular, we learn the color patterns
        // as well as position and size patterns based off such information, to inform us of what we desire to explore
        // when it comes to creativity. We will remain very focused on one aspect of it.
        
        // 
        // Train the model based off TensorFlow.
        
        // Generate the SVG models so that it fits perfectly with the data.
    },
    
    // Try to generate basic SVG from PNG shapes
    
    
    // Novelty score index.
    
    // Add data from our drawing canvas
    addLocalData: function() {
        this.modelMemory.push(helperCreateNeuralImageModel());
    },
    
    writeModel: function(model, clear=true) {
        helperWriteNeuralImageModel(model, clear);
    },
    
    // Model parameters + shape data.
    obspecModelParam: function() {
        var ultimateCollection = [];
        
        var index;
        for(index = 0; index < this.modelMemory.length; index++) {
            var collections = {
                type: [],
                x: [],
                y: [],
                w: [],
                h: [],

                fill: [],
                stroke: [],
                strokeWidth: [],
            }

            var myModel = this.modelMemory[index];
            
            // Grab the model
            for(var j = 0; j < myModel.objects.length; j++) {
                // Grab the model
                var localModel = myModel.objects[j];

                collections.type.push(localModel.type);
                collections.x.push(localModel.x);
                collections.y.push(localModel.y);
                collections.w.push(localModel.width);
                collections.h.push(localModel.height);

                collections.fill.push(localModel.fill);
                collections.stroke.push(localModel.stroke);
                collections.strokeWidth.push(localModel.strokeWidth);
            }
            
            ultimateCollection.push(collections)
        }
        
        return ultimateCollection;
    },
    
    // Just the model params
    modelParam: function() {
        var collections = {
            type: [],
            x: [],
            y: [],
            w: [],
            h: [],
            
            fill: [],
            stroke: [],
            strokeWidth: [],
        }
        
        var index;
        for(index = 0; index < this.modelMemory.length; index++) {
            var myModel = this.modelMemory[index];
            
            // Grab the model
            for(var j = 0; j < myModel.objects.length; j++) {
                // Grab the model
                var localModel = myModel.objects[j];

                collections.type.push(localModel.type);
                collections.x.push(localModel.x);
                collections.y.push(localModel.y);
                collections.w.push(localModel.width);
                collections.h.push(localModel.height);

                collections.fill.push(localModel.fill);
                collections.stroke.push(localModel.stroke);
                collections.strokeWidth.push(localModel.strokeWidth);
            }
        }
        
        return collections;
    },
    
    findStrokeExpectations: function() {
        
    },
    
    generateModel() {
        // Generate something new
        if(this.modelMemory.length > 0) {
            return this.bdiEngine.generateFromBDI();
        }
        return null;
    },
    
    generateAndWriteModel() {
        // Generate something new
        var m = this.generateModel();
        if(m != null) {
            this.writeModel(m);
            
            // Run the desires step here.
            // this.bdiEngine.runDesiresStep();
        }
        else {
            if(painter) painter.showBannerBox("There's nothing for me... draw up an image and I will fiddle around with it - remember to click 'Save it!' for me!", "info");
        }
    },
    
    loadFromSave(refreshBDI=true) {
        var myself = this;
        // Load and parse, assuming not empty
        $.ajax(SAVE_PATH, {data:{load: 1}}).done(function(data) {
            if(data !== null && data !== "") {
                console.log(data);
                myself.modelMemory = JSON.parse(data);
                if(painter) painter.showBannerBox("Loaded some previous data!", "info")
                
                // Wait for load to complete before refreshing beliefs
                if(refreshBDI) myself.bdiEngine.refreshBeliefs(myself);
            }
        });
    },
    
    loadBDIFromSave() {
        var myself = this;
        // Load and parse, assuming not empty
        $.ajax(BDI_SAVE_PATH, {data:{load: 1}}).done(function(data) {
            if(data !== null && data !== "") {
                console.log(data);
                var bdi = JSON.parse(data);
                if(painter) painter.showBannerBox("Loaded the previous BDI model!!", "info")
                
                // Wait for load to complete before refreshing beliefs
                if(bdi != null) {
                    console.log("BDI model: ", bdi);
                    if(bdi.beliefs != null)
                        myself.bdiEngine.beliefs = bdi.beliefs;
                    if(bdi.desires != null)
                        myself.bdiEngine.desires = bdi.desires;
                }
                else {
                    console.log("No BDI model found...");
                }
                // Intentions are a constant set, called by the AI.
            }
            else {
                console.log("No BDI model data found...");
            }
        });
    },
    
    saveToStore() {
        var jsonEnc = JSON.stringify(this.modelMemory);
        
        // Save the model here
        $.post(SAVE_PATH, {save: jsonEnc}).done(function() {
            // Success
            if(painter) painter.showBannerBox("Saved it!", "info");
        });
    },
    
    // From https://stackoverflow.com/questions/8779249/how-to-stringify-inherited-objects-to-json
    // Tomas Vana.
    flatten(obj) {
        var result = Object.create(obj);
        for(var key in result) {
            result[key] = result[key];
        }
        return result;
    },
    
    saveBDIToStore() {
        var bdiMod = {beliefs: this.flatten(this.bdiEngine.beliefs), desires: this.flatten(this.bdiEngine.desires)};
        console.log(bdiMod);
        var jsonEnc = JSON.stringify(bdiMod);
        
        // Save the model here
        $.post(BDI_SAVE_PATH, {save: jsonEnc}).done(function() {
            // Success
            if(painter) painter.showBannerBox("Saved the BDI model!", "info");
        });
    },
    
    clearAllModels() {
        this.modelMemory = [];
        
        $.post(SAVE_PATH, {delete: 1}).done(function() {
            if(painter) painter.showBannerBox("Deleted all previous model information.", "info");
        });
        
        $.post(BDI_SAVE_PATH, {delete: 1}).done(function() {
            // Also deleted...
        });
    },
    
    clearBDIModel() {
        this.modelMemory = [];
        
        $.post(BDI_SAVE_PATH, {delete: 1}).done(function() {
            if(painter) painter.showBannerBox("Deleted the BDI model. Perhaps refresh the page?", "info");
        });
    },
    
    performSaveStep() {
        this.addLocalData();
        this.saveToStore();
        
        this.bdiEngine.refineBeliefs(this);
    },
    
    init() {
        // Last model in memory
        this.loadFromSave();
        
        this.loadBDIFromSave();
    },
    
    askQuestion() {
        // Ask a random question from BDI.
        this.bdiEngine.askQuestionIntention();
    },
};


function Hotspots() {
    
}
Object.assign(Hotspots.prototype, hotspots)
